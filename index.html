<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Carte Leaflet avec centrage sur ma position</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #map {
            height: 90vh;
            width: 100%;
        }
        #info {
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            font-size: 20px;
            font-weight: bold;
            text-align: center;
            border-bottom: 1px solid #ccc;
            height: 10vh;
        }
        #info div {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="info">
        <div id="sup_id"></div>
        <div id="sta_nm_anfr"></div>
        <div id="distance"></div>
        <div id="azimuth"></div>
    </div>
    <!-- Script Leaflet -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
    <!-- Script Papa Parse pour lire le CSV -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script>
        // Position de départ
        const defaultLat = 47.3513162;
        const defaultLon = -2.0982229;

        // Initialisation de la carte
        const map = L.map('map').setView([defaultLat, defaultLon], 13);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        // Variables globales
        let userLat, userLon;
        let selectedLine = null;
        let selectedStation = null;
        let userCircle = null;
        let stationsMarkers = [];
        let stations = [];

        // Fonction pour calculer la distance entre deux points en km
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371;
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        // Fonction pour calculer l'azimuth entre deux points (en degrés)
        function calculateAzimuth(lat1, lon1, lat2, lon2) {
            const y = Math.sin(lon2 - lon1) * Math.cos(lat2);
            const x = Math.cos(lat1) * Math.sin(lat2) -
                      Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
            let azimuth = Math.atan2(y, x) * 180 / Math.PI;
            azimuth = (azimuth + 360) % 360;
            return azimuth.toFixed(1);
        }

        // Fonction pour trouver les 10 stations les plus proches
        function findNearestStations(stations, lat, lon, count = 10) {
            return stations
                .map(station => ({
                    ...station,
                    distance: calculateDistance(lat, lon, station.Latitude, station.Longitude),
                    azimuth: calculateAzimuth(station.Latitude, station.Longitude, lat, lon)
                }))
                .sort((a, b) => a.distance - b.distance)
                .slice(0, count);
        }

        // Fonction pour afficher les stations sur la carte
        function displayStations(stations) {
            stationsMarkers.forEach(marker => map.removeLayer(marker));
            stationsMarkers = [];
            stations.forEach(station => {
                const marker = L.marker([station.Latitude, station.Longitude]).addTo(map);
                marker.on('click', () => onStationSelected(station));
                stationsMarkers.push(marker);
            });
        }

        // Fonction appelée quand une station est sélectionnée
        function onStationSelected(station) {
            selectedStation = station;
            updateSelectedStationInfo();
        }

        // Fonction pour mettre à jour les infos de la station sélectionnée
        function updateSelectedStationInfo() {
            if (!selectedStation || !userLat || !userLon) return;

            // Effacer l'ancienne ligne
            if (selectedLine) {
                map.removeLayer(selectedLine);
            }

            // Tracer une ligne entre la station et l'utilisateur
            selectedLine = L.polyline([
                [userLat, userLon],
                [selectedStation.Latitude, selectedStation.Longitude]
            ], {color: 'red'}).addTo(map);

            // Recalculer distance et azimuth
            const distance = calculateDistance(userLat, userLon, selectedStation.Latitude, selectedStation.Longitude);
            const azimuth = calculateAzimuth(selectedStation.Latitude, selectedStation.Longitude, userLat, userLon);

            // Afficher les informations en haut de la page
            document.getElementById('sup_id').textContent = `SUP_ID: ${selectedStation.SUP_ID}`;
            document.getElementById('sta_nm_anfr').textContent = `STA_NM_ANFR: ${selectedStation.STA_NM_ANFR}`;
            document.getElementById('distance').textContent = `Distance: ${distance.toFixed(2)} km`;
            document.getElementById('azimuth').textContent = `Azimuth: ${azimuth}°`;

            // Centrer la carte sur l'utilisateur et la station sélectionnée
            const group = L.featureGroup([
                L.latLng(userLat, userLon),
                L.latLng(selectedStation.Latitude, selectedStation.Longitude)
            ]);
            map.fitBounds(group.getBounds().pad(0.5));
        }

        // Fonction pour mettre à jour la position de l'utilisateur
        function updateUserPosition() {
            map.locate({setView: true, maxZoom: 15});
        }

        // Géolocalisation de l'utilisateur
        function onLocationFound(e) {
            userLat = e.latlng.lat;
            userLon = e.latlng.lng;

            // Mettre à jour le cercle de l'utilisateur
            if (userCircle) {
                map.removeLayer(userCircle);
            }
            userCircle = L.circle([userLat, userLon], {
                color: 'blue',
                fillColor: 'blue',
                fillOpacity: 1,
                radius: 10
            }).addTo(map);

            // Afficher les 10 stations les plus proches
            const nearestStations = findNearestStations(stations, userLat, userLon);
            displayStations(nearestStations);

            // Mettre à jour les infos si une station est sélectionnée
            if (selectedStation) {
                updateSelectedStationInfo();
            }
        }

        function onLocationError(e) {
            alert("Impossible de récupérer votre position : " + e.message);
        }

        // Charger le fichier CSV
        Papa.parse('resultat.csv', {
            download: true,
            header: true,
            complete: function(results) {
                stations = results.data;
                // Afficher les 10 stations les plus proches de la position par défaut
                const nearestStations = findNearestStations(stations, defaultLat, defaultLon);
                displayStations(nearestStations);
            }
        });

        // Demander la localisation de l'utilisateur
        map.on('locationfound', onLocationFound);
        map.on('locationerror', onLocationError);
        map.locate({setView: true, maxZoom: 16});

        // Rafraîchir la position toutes les 10 secondes
        setInterval(updateUserPosition, 10000);
    </script>
</body>
</html>
